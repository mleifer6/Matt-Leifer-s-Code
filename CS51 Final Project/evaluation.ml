open Expr ;;

(* Exception for evaluator runtime generated by a runtime error *)
exception EvalError of string ;;
(* Exception for evaluator runtime generated by an explicit "raise" construct *)
exception EvalException ;;

module type Env_type = sig
    type env
    type value =
       | Val of expr
       | Closure of (expr * env)
    val create : unit -> env
    val close : expr -> env -> value
    val lookup : env -> varid -> value
    val extend : env -> varid -> value ref -> env
    val env_to_string : env -> string
    val value_to_string : ?printenvp:bool -> value -> string
  end

module Env : Env_type =
  struct

    type env = (varid * value ref) list
     and value =
       | Val of expr
       | Closure of (expr * env)

    exception EnvUnbound

    (* Creates an empty environment *)
    let create () : env = [] ;;

    (* Creates a closure from an expression and the environment it's
       defined in *)
    let close (exp: expr) (env: env) : value =
      Closure(exp, env)

    (* Looks up the value of a variable in the environment *)
    let rec lookup (env: env) (varname: varid) : value =
      match env with 
      | [] -> raise EnvUnbound
      | (v_id,value)::t -> if v_id = varname then !value else lookup t varname

    (* Returns a new environment just like env except that it maps the
       variable varid to loc *)
    let rec extend (env: env) (varname: varid) (loc: value ref) : env =
      match env with 
      | [] -> [(varname,loc)]
      | (v_id,value)::t -> if v_id = varname then (v_id,loc)::t
                           else (v_id,value) :: (extend t varname loc)
     

    (* Returns a printable string representation of an environment *)
    let rec env_to_string (env: env) : string =
      let rec env_to_string_aux env = 
        match env with 
        | [] -> ""
        | [(v_id,value)] -> "(" ^ v_id ^ "," ^ value_to_string ~printenvp:true
                            !value ^ ")"
        | (v_id,value)::t -> "(" ^ v_id ^ "," ^ value_to_string ~printenvp:true
                            !value ^ "); " ^ env_to_string_aux t 
      in "[" ^ env_to_string_aux env ^ "]"

    (* Returns a printable string representation of a value; the flag
       printenvp determines whether to include the environment in the
       string representation when called on a closure *)
     and value_to_string ?(printenvp : bool = true) (v: value) : string =
      match v with 
      | Val e -> "Val(" ^ exp_to_string e ^ ")"
      | Closure(e,env) -> "Closure(" ^ exp_to_string e ^
                          if printenvp then "," ^ env_to_string env ^ ")"
                          else ",<env>)"
  end
;; 
(* The evaluation function: Returns the result of type `value` of
   evaluating the expression `exp` in the environment `env`. In this
   initial implementation, we just convert the expression unchanged to
   a value and return it. *)


let eval_t exp _env = Env.Val exp ;;

(* Helper functions for eval_s and eval_d *)

let binop_eval b e1 e2 = 
  match e1, e2 with 
  | Num n1, Num n2 -> 
    (match b with 
     | "=" -> Bool(n1 = n2)
     | "<" -> Bool(n1 < n2)
     | "+" -> Num(n1 + n2)
     | "-" -> Num(n1 - n2)
     | "*" -> Num(n1 * n2)
     | "/" -> Num(n1 / n2)
     | _ -> raise (EvalError "Invalid Binop for ints"))
  | Bool b1, Bool b2 -> 
    (match b with 
     | "=" -> Bool(b1 = b2)
     | "<" -> Bool(b1 < b2)
     | _ -> raise (EvalError "Invalid Binop for bools"))
  | Str s1, Str s2 -> 
    (match b with 
     | "^" -> Str(s1 ^ s2)
     | _ -> raise (EvalError "Invalid Binop for strings"))
  | Float f1, Float f2 -> 
    (match b with 
     | "=" ->  Bool(f1 = f2)
     | "<" ->  Bool(f1 < f2)
     | "+." -> Float(f1 +. f2)
     | "-." -> Float(f1 -. f2)
     | "*." -> Float(f1 *. f2)
     | "/." -> Float(f1 /. f2)
     | _ -> raise (EvalError "Invalid Binop for floats"))
  | List l1, List l2 -> 
    (match b with 
     | "@" -> List(l1 @ l2)
     | "::" -> List(e1 :: l2)
     | _ -> raise (EvalError "Invalid Binop for lists"))
  | _ , List l -> 
    (match b with 
     | "::" -> List(e1::l)
     | _ -> raise (EvalError "Only the :: can add an expr to a list"))
  | _ -> raise (EvalError "Binop type mismatch") ;;
 
let unop_eval u e = 
  match u, e with 
  | "~", Num n -> Num (~- n)
  | "~.", Float f -> Float (~-. f)
  | _ -> raise (EvalError "Unknown operator; float or int expected")

(*************************** Subsitution Semantics ***************************)

let eval_s exp env = 
  let rec eval_s_aux exp = 
    let conditional_eval e1 e2 e3 = 
      match e1 with 
      | Bool b -> if b then eval_s_aux e2 else eval_s_aux e3
      | _ -> raise (EvalError "Boolean expected; conditino not evaluated") in
    let application_eval e1 e2 = 
      match e1 with 
      | Fun(x1, e3) -> 
        if x1 = "()" && e2 <> Unit 
        then raise (EvalError "expression of type unit expected")
        else eval_s_aux (subst x1 e2 e3)
      | _ -> raise (EvalError "Input must be a function to be applied") in
    let let_rec_eval x e1 e2 = 
      let q' = subst x (Letrec(x,e1,Var(x))) e1 in 
      let r = eval_s_aux (subst x q' e2) in r
      in 
    match exp with 
    | Var x -> raise (EvalError ("Unbound variable " ^ x))
    | Num _ | Bool _ | Str _ | Float _ | Unit -> exp
    | Unop (u,e) -> unop_eval u (eval_s_aux e)
    | Binop(b,e1,e2) -> binop_eval b (eval_s_aux e1) (eval_s_aux e2)
    | Conditional(e1,e2,e3) -> conditional_eval (eval_s_aux e1) e2 e3
    | Fun _ -> exp
    | Let(x, e1, e2) -> eval_s_aux (subst x (eval_s_aux e1) e2)
    | Letrec(x, e1, e2) -> let_rec_eval x e1 e2
    | Raise -> raise EvalException
    | Unassigned -> raise (EvalError "Unassigned shouldn't appear with eval")
    | App(e1, e2) -> application_eval (eval_s_aux e1) (eval_s_aux e2)
    | List(exp_list) -> List(List.fold_right 
                                (fun e acc -> (eval_s_aux e)::acc) exp_list [])
  in eval_t (eval_s_aux exp) env

(*************************** Environment Semantics ***************************)


let eval_d exp env =
  let not_assigned env x = 
    match Env.lookup env x with 
    | Val _ -> false 
    | _ -> true in 
  let rec eval_d_aux exp env = 
    match exp with 
    | Var x -> (match (Env.lookup env x) with 
               | Val v -> eval_d_aux v env
               | Closure _ -> failwith "Closures shouldn't be in eval_d") 
    | Num _ | Bool _ | Str _ | Float _ | Unit -> exp
    | Unop(u, e) -> 
        let e' = (eval_d_aux e env) in 
        unop_eval u e'
    | Binop(b, e1, e2) -> 
        let e1' = eval_d_aux e1 env in 
        let e2' = eval_d_aux e2 env in 
        binop_eval b e1' e2' 
    | Conditional(e1, e2, e3) -> 
        (match (eval_d_aux e1 env) with 
         | Bool b -> if b then eval_d_aux e2 env else eval_d_aux e3 env
         | _ -> raise (EvalError "Boolean expected; condition not evaluated"))
    | Fun _ -> exp
    | Let(x, q, p) -> ( if List.mem x (all_vars q) && not_assigned env x
                          then raise (EvalError ("Unbound variable " ^ x)) else
                        let q' = eval_d_aux q env in 
                        eval_d_aux p (Env.extend env x (ref (Env.Val q')))) 
    | Letrec(x, q, p) ->(let env' = Env.extend env x (ref (Env.Val Unassigned)) in
                         let q' = eval_d_aux q env' in 
                         (*let _ = Env.extend env' x (ref (Env.Val q')) in *)
                         let env'' = Env.extend env' x (ref (Env.Val q')) in
                         eval_d_aux p env'')
    | Raise -> raise EvalException
    | Unassigned -> raise (EvalError "Unassigned reached")
    | App(p, q) -> (match (eval_d_aux p env) with 
                   | Fun(x, b) -> let q' = eval_d_aux q env in
                      if x = "()" && q' <> Unit
                      then raise (EvalError "expression of type unit expected")
                      else eval_d_aux b (Env.extend env x (ref (Env.Val q')))
                   | _ -> 
                    raise (EvalError "Input must be a function to be applied"))
    | List(exp_list) -> List(List.fold_right 
                            (fun e acc -> (eval_d_aux e env)::acc) exp_list [])
  in eval_t (eval_d_aux exp env) env

(****************************** Lexical Scoping ******************************)

let eval_l exp env =
  failwith "eval_l not implemented"

let evaluate = eval_s;;
